# 一、题目

> 这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。

提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。

**输入格式：**
> 输入在一行中给出一个不以5结尾的正奇数x（<1000）。


**输出格式：**

> 在一行中输出相应的最小的s和n，其间以1个空格分隔。


**输入样例1：**
31

**输出样例1：**

3584229390681 15




 

# 二、解决方案
# 1.思路
①这道题因为数值太大，所以我们就选择一位一位的打印。
②先找出第一个大于x的值v，然后相除得到我们需要的第一个数字，之后我们取余数，然后再让余数*10+1，以此类推继续求下一个数，直到取余为0为止
③注意我们还要得到1的个数，所以我们定义一个count=1（最后一个数字会跳出，无法让count++，所以我们直接定义count=1，而不是count=0），在我们求每一个数字的时候都要让count++。

——————————————
# 2.代码

```c
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int main()
{
	int x = 0,count=1,v=1;
	scanf("%d", &x);
	while (v < x)
	{
		v = v * 10 + 1;
		count++;
	}
	while (1)
	{
		printf("%d", v/x);
		if (v % x == 0)
			break;
		else
		{
			v = v % x * 10 +1;
			count++;
		}
	}
	printf(" %d", count);
	return 0;
}
```

