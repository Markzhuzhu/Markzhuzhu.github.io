# 一、题目

> 题的目标很简单，就是求两个正整数A和B的和，其中A和B都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。
> 
> 
**输入格式：**
> 输入在一行给出A和B，其间以空格分开。问题是A和B不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。

注意：我们把输入中出现的第1个空格认为是A和B的分隔。题目保证至少存在一个空格，并且B不是一个空字符串。


**输出格式：**

> 如果输入的确是两个正整数，则按格式A + B = 和输出。如果某个输入不合要求，则在相应位置输出?，显然此时和也是?。

**输入样例1：**

123 456

**输出样例1：**

123 + 456 = 579

**输入样例2：**

22. 18

**输出样例2：**

? + 18 = ?

**输入样例3：**

-100 blabla bla...33

**输出样例3：**

? + ? = ?


 
 

# 二、解决方案
# 1.思路
我们先定义两个字符数组，来存放输入的两个字符串，不用整形数组是因为输入的数字可能为乱码或者其他不符合要求的数字，之后我们判断每个数组里的字符串是不是符合题意的字符数字，最后输出结果即可
注意：①输入时，一个空格为分隔，然后B不是一个空字符串，然后我们可以看到样例3中B字符串之间有空格，这里输入B的时候我们就不能用scanf，要用gets，因为scanf不能读取空格，但是gets可以，这样我们就可以将gets里的一个空格当做A和B的分隔，这样要注意之后遍历arr2的时候，i=1截止，而不是i=0，因为i=0对应的是空格，

——————————————
# 2.代码

```c
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
int main()
{
	char arr1[1000] = { 0 };
	char arr2[1000] = { 0 };
	scanf("%s", arr1);
	gets(arr2);
	int len1 = strlen(arr1);
	int len2 = strlen(arr2);
	int a=0, b=0;
	int flag1 = 1,flag2=1,t=1;//是正整数;
	for (int i = len1-1; i>=0; i--)
	{
		if (arr1[i] < '0' || arr1[i] > '9')
		{
			flag1 = 0;
			break;
		}
		else
		{
			a += t * (arr1[i] - '0');
			t *= 10;
		}
	}
	if (a > 1000 || a < 1)
	{
		flag1 = 0;
	}
	t = 1;
	for (int i = len2-1; i>=1; i--)
	{
		if (arr2[i]< '0' || arr2[i] > '9')
		{
			flag2 = 0;
			break;
		}
		else
		{
			b += t * (arr2[i] - '0');
			t *= 10;
		}
	}
	if (b > 1000 || b < 1)
	{
		flag2 = 0;
	}
	if (flag1 == 1 && flag2 == 1)
	{
		printf("%d + %d = %d", a, b, a + b);
	}
	else if (flag1==0&&flag2==1)
	{
		printf("? + %d = ?", b);
	}
	else if (flag1==1&&flag2==0)
	{
		printf("%d + ? = ?", a);
	}
	else
	{
		printf("? + ? = ?");
	}
	return 0;
}
```

